#R

#' Summary of a MSM object.
#'
#' @param jobj a Java object reference generated by \code{\link{jCreateMSM}}.
#'
#' @return a \code{\link{data.frame}}
#' @export jSummaryMSM
#' @author Lucas Schmidt, Witold E. Wolski, Christian Panse
#' @importFrom utils read.csv
#' 
#' @seealso \code{\link{jCreateMSM}}
#' 
#' @examples
#' load(system.file("extdata",
#'    name='TP_HeLa_200ng_filtered_pd21.RData', package = "deisotoper"))
#'  joMSM <- jCreateMSM(TP_HeLa_200ng_filtered_pd21)
#'  X <- jSummaryMSM(joMSM)
#'  
#' par(mfrow=c(3,4)); 
#' rv <- lapply(unique(X$Attribute), 
#'  function(a){
#'    hist(X[X$Attribute == a, 3],xlab=a, main='Histgram')
#'    })
#' 
#' if(require(lattice)){
#' 
#' xyplot(Value ~ SpectrumID | Attribute,
#'  data=X, 
#'  pch='.')
#'
#'  xyplot(Value ~ SpectrumID | Attribute, data=X, scales = list(y=list(log=TRUE)))
#'    
#'    
#'  histogram(~Value | Attribute, data=X)
#'  histogram(~Value|Attribute, data=X, scales = list(x=list(log=TRUE)))
#'  histogram(~Value|Attribute, data=X, scales = list(x=list(log=TRUE)), type='count')
#' 
#'  bwplot(~Value | Attribute, data=X, scales = list(x = list(log = TRUE)))
#'  }
jSummaryMSM <- function(jobj){
  .jinit(parameters = "-XX:-UseGCOverheadLimit")
  .jaddClassPath("inst/java/deisotoper.jar")
  .jclassPath()
  
  sum <- .jnew("ch.fgcz.proteomics.R.UtilitiesR")
  
  summary <- .jcall(sum, "S", "summaryMSMR", jobj)
  con <- textConnection(summary)
  read.csv(con, sep=',', header = TRUE)
}

#' Makes summary from one massspectrum
#'
#' @param jobj 
#'
#' @return csv
#' @export jSummaryMS
#' @author Lucas Schmidt
jSummaryMS <- function(jobj){
  .jinit(parameters = "-XX:-UseGCOverheadLimit")
  .jaddClassPath("inst/java/deisotoper.jar")
  .jclassPath()
  
  sum <- .jnew("ch.fgcz.proteomics.R.UtilitiesR")
  
  summary <- .jcall(sum, "S", "summaryMSR", jobj)
  con <- textConnection(summary)
  read.csv(con, sep=',', header = TRUE)
}

#' find index of nearest neighbor.
#'
#' @param q a double vector which can be considered as query objects.
#' @param vec a sorted double vector which can be considered as a data base.
#'
#' @description Given a vector of sorted double values \code{vec} of size
#' \code{n} and a vector of \code{m} query objects \code{q}.
#'
#' \code{findNN} determines for each element \code{q[i]} in \code{q}
#' the nearest neighbor index \code{o} so that the following remains true:
#'  
#'  there is no element \code{k} with \code{1} \eqn{\le} \code{k}
#' \eqn{\le} \code{n} and \code{k} is not \code{o} so that
#'
#' \code{abs(vec[k] - q[i])} < \code{abs(vec[o] - q[i])}.
#' 
#'  The internal algorithm of \code{findNN} is implemented as binary search.
#' \code{findNN} has \eqn{O(m * log(n))} time complexity.
#'
#' @author Lucas Schmidt, Christian Panse
#' @seealso \code{protViz::findNN}'s cpluplus implementation.
#' @return an integer vector 
#' @export findNN
#' 
#' @examples
#' (NNidx <- findNN(q<-c(1, 1.0001, 1.24, 1.26), DB<-seq(1,5,by=0.25)))
#' (NNidx == c(1,1,2,2))
#' 
#' # should be 0
#' unique(DB[findNN(DB,DB)] - DB)
findNN <- function (q, vec) {
  .jinit()
  .jaddClassPath("inst/java/deisotoper.jar")
  .jclassPath()

  jFindNN <- .jnew("ch.fgcz.proteomics.R.UtilitiesR")
  
  idx <- .jcall(jFindNN, "[D", "findNNR", as.double(q), as.double(vec))
  
  idx
}

#' Coerce to MS.
#'
#' @param x 
#' @description Functions to check if an object is a MS, or coerce it if possible.
#' @return \code{TRUE} or \code{FALSE}
#' @export is.MS 
is.MS <- function(x){
  
  if (sum(c("title", "rtinseconds", "charge","scan","pepmass","mZ","intensity") %in% names(x)) != 7){
    warning('attributed check failed.')
    #return (FALSE)
  }
  
  if (!is.vector(x$mZ) || !is.numeric(x$mZ) || is.unsorted(x$mZ)){
    warning('mZ value check failed.')
    warning(x$mZ)
    return(FALSE)
  }
    
  if (!is.vector(x$intensity) || !is.numeric(x$intensity)){
    warning('intensity check failed.')
    return(FALSE)
  }
  
  if (!is.numeric(x$pepmass) || !is.numeric(x$rtinseconds) || !is.numeric(x$charge) || !is.numeric(x$id)){
     warning('pepmass, rtinseconds, ... check failed.')
     return (FALSE)
  }
  
  TRUE
}


#' Coerce to MSM.
#'
#' @param x 
#' @description Functions to check if an object is a MSM, or coerce it if possible.
#' @return \code{TRUE} or \code{FALSE}
#' @export is.MSM
is.MSM <- function(x){
  rv <- sapply(x, function(y){
    if (!is.MS(y)){
      return (FALSE)
    }
    TRUE
  })
  sum(rv) ==  length(rv)
}

#' creates Mass Spectrometry Measurement (MSM) Java object .
#'
#' @param obj \code{protViz""psmSet} object
#'
#' @return returns a jcall object reference
#' 
#' @seealso \code{\link{jSummaryMSM}}
#' @import rJava
#' @export jCreateMSM
#' @author Lucas Schmidt, Witold E. Wolski, Christian Panse
#' 
#' @examples 
#' load(system.file("extdata",
#'    name='TP_HeLa_200ng_filtered_pd21.RData', package = "deisotoper"))
#' joMSM <- jCreateMSM(TP_HeLa_200ng_filtered_pd21)
#' 
#' 
#' \dontrun{
#'  mzXMLfilename <- system.file("extdata",
#'       name='20161010_04_TP_HeLa_200ng.mzXML', package = "deisotoper")
#'       
#'  jo <- jCreateMSM(as.psmSet.mzXML(openMSfile(mzXMLfilename)))
#' }
jCreateMSM <- function (obj) {
  src <- deparse(substitute(obj))
  
 
    obj <- as.MSM(obj)
 
  
  .jinit(parameters = "-XX:-UseGCOverheadLimit")
  .jaddClassPath("inst/java/deisotoper.jar")
  .jclassPath()
  
  DataTransferObjectR <- .jnew("ch.fgcz.proteomics.R.DataTransferObjectR")
  
  MSM <- .jcall(DataTransferObjectR, "Lch/fgcz/proteomics/dto/MassSpectrometryMeasurement;", "massSpectrometryMeasurementR", src)
  
  lapply(obj, function(x) {
    if (is.null(x))
      {return (x)}
    if(!'id' %in% names(x)){
      x$id <- 0
    }
    
    if (!'title' %in% names(x)){
      x$title <- "xx"
    }
    
    .jcall(MSM, "V", "addMS", "MS2 Spectrum", x$title, x$mZ, x$intensity,
           x$pepmass, x$rtinseconds, as.integer(x$charge), as.integer(x$id))
  })
  
  MSM
}

#' Coerce to MS.
#'
#' @param x 
#' @description Functions to check if an object is a MSM, or coerce it if possible.
#' @return \code{TRUE} or \code{FALSE}
#' @export as.MS
as.MS<- function(x){
  
  
  if ('mZ' %in% names(x) && length(x$mZ) < 2){
    return (NULL)
  }
  if (!('pepmass' %in% names(x)) || is.na(x$pepmass)){
    x$pepmass <- 100.0
  }
  
  if (!('title' %in% names(x)) || is.na(x$title) ){
    x$title <- "no title"
  }
  
  if (!('rtinseconds' %in% names(x)) || is.na(x$rtinseconds) ){
    x$rtinseconds <- 1
  }
  
  if ( !('charge' %in% names(x)) || is.na(x$charge) ){
    x$charge <- 1
  }
  
  if ( !('id' %in% names(x)) || is.na(x$id)){
    x$id <- 1
  }
  
  
  if(is.unsorted(x$mZ)){
    idx<-order(x$mZ)
    x$mZ <- x$mZ[idx]
    x$intensity <- x$intensity[idx]
  }
  
  stopifnot(is.MS(x))
  
  x
}

#' Coerce to MSM.
#'
#' @param x 
#' @description Functions to check if an object is a MSM, or coerce it if possible.
#' @return \code{TRUE} or \code{FALSE}
#' @export as.MSM
as.MSM <-function(x){
  filter <- sapply(x, function(y){length(y$mZ) > 1})
  x <- lapply(x[filter], as.MS)
  stopifnot(is.MSM(x))
  x
}

#' Gets the MSM from Java to R.
#'
#' @param jobj 
#'
#' @export jGetMSM
#' @author Lucas Schmidt
#' 
#' @examples 
#' load(system.file("extdata",
#' name='TP_HeLa_200ng_filtered_pd21.RData', package = "deisotoper"))
#' joMSM <- jCreateMSM(TP_HeLa_200ng_filtered_pd21)
jGetMSM <- function(jobj) {
  .jinit(parameters = "-XX:-UseGCOverheadLimit")
  .jaddClassPath("inst/java/deisotoper.jar")
  .jclassPath()
  
  source <- .jcall(jobj, "S", "getSource")
  
  MSlist <- .jcall(jobj, "Ljava/util/List;", "getMSlist")
  
  MSlistR <- rJava:::as.list.jobjRef(MSlist)
  
  MSM <- lapply(1: length(MSlistR), function(i){
    
    typ <- .jcall(MSlistR[[i]], "S", "getTyp")
    searchengine <- .jcall(MSlistR[[i]], "S", "getSearchEngine")
    id <- .jcall(MSlistR[[i]], "I", "getId")
    charge <- .jcall(MSlistR[[i]], "[I", "getChargeArray")
    isotope <- .jcall(MSlistR[[i]], "[D", "getIsotopeArray")
   
    
    
    list(mZ =.jcall(MSlistR[[i]], "[D", "getMzArray"),
         intensity = .jcall(MSlistR[[i]], "[D", "getIntensityArray"),
         rtinseconds = .jcall(MSlistR[[i]], "D", "getRt"),
         pepmass = .jcall(MSlistR[[i]], "D", "getPeptideMass"),
         id =  .jcall(MSlistR[[i]], "I", "getId"),
         charge = .jcall(MSlistR[[i]], "I", "getChargeState"),
         scans = .jcall(MSlistR[[i]], "I", "getId"),
         title = paste('deisotoped', i))
  }
  )
  
  as.MSM(MSM)
}

#' Serializes a MSM into a json.
#'
#' @param jobj 
#' @param filename 
#'
#' @export jWriteMSM2JSON
#' @author Lucas Schmidt
jWriteMSM2JSON <- function(jobj, filename='test.json'){
  .jinit(parameters = "-XX:-UseGCOverheadLimit")
  .jaddClassPath("inst/java/deisotoper.jar")
  .jaddClassPath("inst/java/gson-2.8.1.jar")
  .jclassPath()
  Serialize <- .jnew("ch.fgcz.proteomics.R.DataTransferObjectR")
  
  json <- .jcall(Serialize, "S", "serializeMSMToJsonR", filename, jobj)
  
  json
}

#' Deserializes a json into a MSM.
#'
#' @param filename 
#'
#' @export jReadJSON2MSM
#' @author Lucas Schmidt
jReadJSON2MSM <- function(filename='test.json'){
  .jinit(parameters = "-XX:-UseGCOverheadLimit")
  .jaddClassPath("inst/java/deisotoper.jar")
  .jaddClassPath("inst/java/gson-2.8.1.jar")
  .jclassPath()
  Serialize <- .jnew("ch.fgcz.proteomics.R.DataTransferObjectR")
  
  MSM <- .jcall(Serialize, "Lch/fgcz/proteomics/dto/MassSpectrometryMeasurement;", "deserializeJsonToMSMR", filename)
  
  MSM
}

#' Returns the version of the Java packages
#'
#' @export jVersion
#' @author Lucas Schmidt
jVersion <- function() {
  .jinit(parameters = "-XX:-UseGCOverheadLimit")
  .jaddClassPath("inst/java/deisotoper.jar")
  .jclassPath()
  
  version <- .jnew("ch.fgcz.proteomics.Version")
  
  version <- .jcall(version, "S", "version")
  
  version
}

#' Deisotopes a MSM.
#'
#' @param jobj 
#' @param modus 
#' @param configfile 
#'
#' @return deisotoped MSM
#' @export jDeisotopeMSM
#' @author Lucas Schmidt
#'
#' @examples
#' load(system.file("extdata", name='TP_HeLa_200ng_filtered_pd21.RData', package = "deisotoper"))
#' joMSM <- jCreateMSM(TP_HeLa_200ng_filtered_pd21)
#'
#' joMSMdeisotoped <- jDeisotopeMSM(joMSM)
#'
#' joMSMsummary <- jSummaryMSM(joMSM)
#' joMSMdeisotopedsummary <- jSummaryMSM(joMSMdeisotoped)
jDeisotopeMSM <- function(jobj, modus="first", configfile="nofile") {
  .jinit(parameters = "-XX:-UseGCOverheadLimit")
  .jaddClassPath("inst/java/deisotoper.jar")
  .jaddClassPath("inst/java/antlr4-runtime-4.5.3.jar")
  .jaddClassPath("inst/java/jgraph-5.13.0.0.jar")
  .jaddClassPath("inst/java/jgrapht-core-1.0.1.jar")
  .jaddClassPath("inst/java/jgrapht-demo-1.0.1.jar")
  .jaddClassPath("inst/java/jgrapht-ext-1.0.1.jar")
  .jaddClassPath("inst/java/jgrapht-ext-1.0.1-uber.jar")
  .jaddClassPath("inst/java/jgraphx-2.0.0.1.jar")
  .jclassPath()
  
  String <- J("java.lang.String")
  m <- new(String, modus)
  config <- new(String, configfile)
  
  d <- .jnew("ch.fgcz.proteomics.R.FeaturesBasedDeisotopingMethodR")
  
  output <- .jcall(d, "Lch/fgcz/proteomics/dto/MassSpectrometryMeasurement;", "deisotopeMSMR", jobj, m, config)
  
  output
}

#' Deisotopes a MS.
#'
#' @param ms 
#' @param modus 
#' @param configfile 
#'
#' @return deisotoped ms
#' @export jDeisotopeMS
#' @author Lucas Schmidt
#'
#' @examples
#' load(system.file("extdata", name='TP_HeLa_200ng_filtered_pd21.RData', package = "deisotoper"))
#' joMSM <- jCreateMSM(TP_HeLa_200ng_filtered_pd21)
#' 
#' mslist<-joMSM$getMSlist()
#' ms <- mslist$get(as.integer(0)) #index 0 of joMSM
#' 
#' msdeisotoped <- jDeisotopeMS(ms)
jDeisotopeMS <- function(ms, modus="first", configfile="nofile") {
  .jinit(parameters = "-XX:-UseGCOverheadLimit")
  .jaddClassPath("inst/java/deisotoper.jar")
  .jaddClassPath("inst/java/antlr4-runtime-4.5.3.jar")
  .jaddClassPath("inst/java/jgraph-5.13.0.0.jar")
  .jaddClassPath("inst/java/jgrapht-core-1.0.1.jar")
  .jaddClassPath("inst/java/jgrapht-demo-1.0.1.jar")
  .jaddClassPath("inst/java/jgrapht-ext-1.0.1.jar")
  .jaddClassPath("inst/java/jgrapht-ext-1.0.1-uber.jar")
  .jaddClassPath("inst/java/jgraphx-2.0.0.1.jar")
  .jclassPath()
  
  String <- J("java.lang.String")
  m <- new( String, modus )
  
  d <- .jnew("ch.fgcz.proteomics.R.FeaturesBasedDeisotopingMethodR")
  
  config <- .jnew("ch.fgcz.proteomics.fbdm.ScoreConfig", configfile)
  
  output <- .jcall(d, "Lch/fgcz/proteomics/dto/MassSpectrum;", "deisotopeMSR", ms, m, config)
  
  output
}


#' Used for benchmarking. The input is a RData and the output is also a MGF.
#'
#' @param input 
#' @param output 
#' @param modus 
#' @param configfile 
#'
#' @return mgf
#' @export jBenchmark
#' @author Lucas Schmidt
jBenchmark <- function(input, output, modus="first", configfile="nofile") {
  name <- load(file = input)
  mgf(jGetMSM(deisotoper:::jDeisotopeMSM(jobj = jCreateMSM(get(name)), modus = modus, configfile = configfile)), filename = output)
}

#' Creates a isotopicmassspectrum from a massspectrum
#'
#' @param massspectrum 
#' @param configfile 
#'
#' @return ims
#' @export jCreateIMS
#' @author Lucas Schmidt
jCreateIMS <- function(massspectrum, configfile = "nofile") {
  .jinit(parameters = "-XX:-UseGCOverheadLimit")
  .jaddClassPath("inst/java/deisotoper.jar")
  .jclassPath()
  
  adapter <- .jnew("ch.fgcz.proteomics.R.FeaturesBasedDeisotopingMethodR")
  
  config <- .jnew("ch.fgcz.proteomics.fbdm.ScoreConfig", configfile)
  
  delta <- config$getDelta()
  
  ims <- .jcall(adapter, "Lch/fgcz/proteomics/fbdm/IsotopicMassSpectrum;", "getIMS", massspectrum, delta, configfile)
  
  ims
}

#' Wrapper function to get a dot graph from a single isotopicset.
#'
#' @param massspectrum 
#' @param isotopicset 
#' @param configfile 
#'
#' @return dot graph
#' @export jGetDotGraphFromIS
#' @author Lucas Schmidt
jGetDotGraphFromIS <- function(massspectrum, isotopicset, configfile = "nofile") {
  .jinit(parameters = "-XX:-UseGCOverheadLimit")
  .jaddClassPath("inst/java/deisotoper.jar")
  .jclassPath()
  
  adapter <- .jnew("ch.fgcz.proteomics.R.FeaturesBasedDeisotopingMethodR")
  
  config <- .jnew("ch.fgcz.proteomics.fbdm.ScoreConfig", configfile)
  
  dot <- .jcall(adapter, "S", "getGraphFromIS", isotopicset, massspectrum, config)
  
  dot
}

#' Returns a single isotopicset.
#'
#' @param isotopicmassspectrum 
#' @param index 
#'
#' @return is
#' @export jGetIS
#' @author Lucas Schmidt
jGetIS <- function(isotopicmassspectrum, index) {
  islist <- isotopicmassspectrum$getIsotopicMassSpectrum()
  is <- islist$get(as.integer(index))
  
  is
}

#' Creates the dot graph from the given massspectrum and the given isotopicset.
#'
#' @param massspectrum 
#' @param isotopicmassspectrum 
#' @param index 
#' @param configfile 
#'
#' @return dot graph
#' @export jGetDot
#' @author Lucas Schmidt
jGetDot <- function(massspectrum, isotopicmassspectrum, index, configfile = "nofile") {
  dot <- jGetDotGraphFromIS(massspectrum = massspectrum,isotopicset = jGetIS(isotopicmassspectrum = isotopicmassspectrum, index = index), configfile = configfile)
  
  dot
}

#' Gets the MS from Java to R.
#'
#' @param massspectrum 
#'
#' @export jGetMS
#' @author Lucas Schmidt
jGetMS <- function(massspectrum) {
  MS <- c(typ <- .jcall(massspectrum, "S", "getTyp"),
  searchengine = searchengine <- .jcall(massspectrum, "S", "getSearchEngine"),
  id = id <- .jcall(massspectrum, "I", "getId"),
  charge = charge <- .jcall(massspectrum, "[I", "getChargeArray"),
  isotope = isotope <- .jcall(massspectrum, "[D", "getIsotopeArray"),
  list(mZ =.jcall(massspectrum, "[D", "getMzArray"),
       intensity = .jcall(massspectrum, "[D", "getIntensityArray"),
       rtinseconds = .jcall(massspectrum, "D", "getRt"),
       pepmass = .jcall(massspectrum, "D", "getPeptideMass"),
       id =  .jcall(massspectrum, "I", "getId"),
       charge = .jcall(massspectrum, "I", "getChargeState"),
       scans = .jcall(massspectrum, "I", "getId"),
       title = "MassSpectrum')")
  )
  
  as.MS(MS)
}

#' Returns the ScoreConfig which is in the properties file as a CSV.
#'
#' @param file 
#'
#' @return csv
#' @export jScoreConfigAsCSV
#' @author Lucas Schmidt
jScoreConfigAsCSV <- function(file){
  .jinit(parameters = "-XX:-UseGCOverheadLimit")
  .jaddClassPath("inst/java/deisotoper.jar")
  .jclassPath()
  
  config <- .jnew("ch.fgcz.proteomics.fbdm.ScoreConfig", file)
  
  adapter <- .jnew("ch.fgcz.proteomics.R.FeaturesBasedDeisotopingMethodR")
  
  csv <- .jcall(adapter, "S", "getScoreConfigAsCSV", config)
  con <- textConnection(csv)
  read.csv(con, sep=',', header = TRUE)
}

#' Creates a properties file as config.
#'
#' @param filename 
#'
#' @export CreateProperties
#' @author Lucas Schmidt
CreateProperties <- function(filename) {
  write(x = "# ScoreConfig", file = filename)
}


#' Key can be: Any Amino Acid (Short form, 1 or 3 letter-code), F1, F2, F3, F4, F5, DISTANCE, DELTA, ERRORTOLERANCE, NOISE.
#'
#' @param filename 
#' @param key 
#' @param value 
#'
#' @export AddToProperties
#' @author Lucas Schmidt
AddToProperties <- function(filename, key, value) {
  write(x = paste(key, "=", value, sep = ""), file = filename, append = TRUE)
}

#' Returns a statistic as CSV
#'
#' @param msm 
#' @param configfile 
#'
#' @return csv
#' @export jGetStatisticMSM
#' @author Lucas Schmidt
jGetStatisticMSM <- function(msm, configfile = "nofile") {
  .jinit(parameters = "-XX:-UseGCOverheadLimit")
  .jaddClassPath("inst/java/deisotoper.jar")
  .jclassPath()
  config <- .jnew("ch.fgcz.proteomics.fbdm.ScoreConfig", configfile)
  
  adapter <- .jnew("ch.fgcz.proteomics.R.FeaturesBasedDeisotopingMethodR")
  
  csv <- .jcall(adapter, "S", "getStatistic", msm, config)
  con <- textConnection(csv)
  read.csv(con, sep=',', header = TRUE)
}

#' Input loaded Obj with [i] (example: obj[1]).
#'
#' @param obj 
#'
#' @return ms
#' @export jCreateMS
#' @author Lucas Schmidt
jCreateMS <- function(obj) {
  if(length(obj) != 1) {
    stop("Error: Object not compatible!")
  }
  
  msm <- jCreateMSM(obj)
  
  mslist<-msm$getMSlist()
  ms <- mslist$get(as.integer(0))
  
  ms
}

#' Reads a MGF and creates a MSM object from the input.
#'
#' @param filename 
#'
#' @return msm
#' @export jReadMGF
#' @author Lucas Schmidt
jReadMGF <- function(filename) {
  .jinit(parameters = "-XX:-UseGCOverheadLimit")
  .jaddClassPath("inst/java/deisotoper.jar")
  .jclassPath()
  
  adapter <- .jnew("ch.fgcz.proteomics.R.MascotGenericFormatR")
  
  msm <- .jcall(adapter, "Lch/fgcz/proteomics/dto/MassSpectrometryMeasurement;", "readR", filename)
  
  msm
}

#' Writes a MGF from a given MSM object.
#'
#' @param filename 
#' @param msm 
#'
#' @return status
#' @export jWriteMGF
#' @author Lucas Schmidt
jWriteMGF <- function(filename, msm) {
  .jinit(parameters = "-XX:-UseGCOverheadLimit")
  .jaddClassPath("inst/java/deisotoper.jar")
  .jclassPath()
  
  adapter <- .jnew("ch.fgcz.proteomics.R.MascotGenericFormatR")
  
  status <- .jcall(adapter, "Z", "writeR", filename, msm)
  
  status
}