#R

#' Summary of a MSM object
#'
#' @param jobj a Java object reference generated by \code{\link{jCreateMSM}}.
#'
#' @return a \code{\link{data.frame}}
#' @export jSummaryMSM
#' @author Lucas Schmidt, Witold E. Wolski, Christian Panse
#' @importFrom utils read.csv
#' 
#' @examples
#' \dontrun{
#'  mzXMLfilename <- system.file("extdata",
#'       name='20161010_04_TP_HeLa_200ng.mzXML', package = "deisotoper")
#'       
#'  jo <- jCreateMSM(as.psmSet.mzXML(openMSfile(mzXMLfilename)))
#'  X <- jSummaryMSM(jo)
#'  
#' library(lattice)
#' 
#' xyplot(Value ~ SpectrumID | Attribute,
#'  data=X, 
#'  pch='.')
#'
#'   xyplot(Value ~ SpectrumID | Attribute, data=X)
#' }

jSummaryMSM <- function(jobj){
  .jinit(parameters = "-XX:-UseGCOverheadLimit")
  .jaddClassPath("inst/java/deisotoper.jar")
  .jclassPath()
  
  sum <- .jnew("ch.fgcz.proteomics.dto.Summary")
  
  summary <- .jcall(sum, "S", "makeSummary", jobj)
  con <- textConnection(summary)
  read.csv(con, sep=',', header = TRUE)
}

#' find index of nearest neighbor 
#'
#' @param q a double vector which can be considered as query objects.
#' @param vec a sorted double vector which can be considered as a data base.
#' @param check boolean enables test if \code{vec} is sorted. default is \code{FALSE}
#'
#' @description Given a vector of sorted double values \code{vec} of size
#' \code{n} and a vector of \code{m} query objects \code{q}.
#'
#' \code{findNN} determines for each element \code{q[i]} in \code{q}
#' the nearest neighbor index \code{o} so that the following remains true:
#'  
#'  there is no element \code{k} with \code{1} \eqn{\le} \code{k}
#' \eqn{\le} \code{n} and \code{k} is not \code{o} so that
#'
#' \code{abs(vec[k] - q[i])} < \code{abs(vec[o] - q[i])}.
#' 
#'  The internal algorithm of \code{findNN} is implemented as binary search.
#' \code{findNN} has \eqn{O(m * log(n))} time complexity.
#'
#' @author Christian Panse
#' @seealso \code{protViz::findNN}'s cpluplus implementation.
#' @return an integer vector 
#' @export findNN
#' 
#' @examples
#' 
#' 
#' (NNidx <- findNN(q<-c(1, 1.0001, 1.24, 1.26), DB<-seq(1,5,by=0.25)))
#' (NNidx == c(1,1,2,2))
#' 
#' # should be 0
#' unique(DB[findNN(DB,DB)] - DB)
#' 
#' 
findNN <- function (q, vec, check = FALSE) {
  .jinit()
  .jaddClassPath("inst/java/deisotoper.jar")
  .jclassPath()

  jFindNN <- .jnew("ch.fgcz.proteomics.utilities.FindNN")
  
  .jcall(jFindNN, "V", "setVec", as.double(vec))
  .jcall(jFindNN, "V", "setQ", as.double(q))
  
  idx <- (.jcall(jFindNN, "[D", "getIndex") + 1)
}

#' creates Mass Spectrometry Measurement (MSM) Java object 
#'
#' @param obj \code{protViz""psmSet} object
#'
#' @return returns a jcall object reference
#' 
#' @import rJava
#' @export jCreateMSM
#' @author Lucas Schmidt, Witold E. Wolski, Christian Panse
#' @examples 
#' load(system.file("extdata",
#'    name='TP_HeLa_200ng_filtered_pd21.RData', package = "deisotoper"))
#' joMSM <- jCreateMSM(TP_HeLa_200ng_filtered_pd21)
#' \dontrun{
#'  mzXMLfilename <- system.file("extdata",
#'       name='20161010_04_TP_HeLa_200ng.mzXML', package = "deisotoper")
#'       
#'  jo <- jCreateMSM(as.psmSet.mzXML(openMSfile(mzXMLfilename)))
#' }
jCreateMSM <- function (obj) {
  src <- deparse(substitute(obj))
  .jinit(parameters = "-XX:-UseGCOverheadLimit")
  .jaddClassPath("inst/java/deisotoper.jar")
  .jclassPath()
  
  MSM <- .jnew("ch.fgcz.proteomics.dto.MassSpectrometryMeasurement", src)
  
  lapply(obj, function(x) {
    
    if(!'id' %in% names(x)){
      x$id <- -1
    }
    
    if (!'searchEngine' %in% names(x)){
      x$searchEngine <- "NA"
    }
    
    .jcall(MSM, "V", "addMS", "MS2 Spectrum", x$searchEngine, x$mZ, x$intensity,
           x$pepmass, x$rtinseconds, as.integer(x$charge), as.integer(x$id))
  })
  
  MSM
}

jGetMSM <- function(jobj) {
  
}

jWriteMSM2JSON <- function(jobj, filename='test.json'){
  .jinit(parameters = "-XX:-UseGCOverheadLimit")
  .jaddClassPath("inst/java/deisotoper.jar")
  .jaddClassPath("inst/java/gson-2.8.1.jar")
  .jclassPath()
  Serialize<- .jnew("ch.fgcz.proteomics.dto.Serialize")
  
  json <- .jcall(Serialize, "S", "serializeMSMToJson", filename, jobj)
  
  json
}

jReadJSON2MSM <- function(filename='test.json'){
  .jinit(parameters = "-XX:-UseGCOverheadLimit")
  .jaddClassPath("inst/java/deisotoper.jar")
  .jaddClassPath("inst/java/gson-2.8.1.jar")
  .jclassPath()
  Serialize <- .jnew("ch.fgcz.proteomics.dto.Serialize")
  
  MSM <- .jcall(Serialize, "Lch/fgcz/proteomics/dto/MassSpectrometryMeasurement;", "deserializeJsonToMSM", filename)
  
  MSM
}

jVersionMSM <- function() {
  .jinit(parameters = "-XX:-UseGCOverheadLimit")
  .jaddClassPath("inst/java/deisotoper.jar")
  .jclassPath()
  
  MSM <- .jnew("ch.fgcz.proteomics.dto.MassSpectrometryMeasurement", " ")
  
  version <- .jcall(MSM, "S", "version")
  
  version
}